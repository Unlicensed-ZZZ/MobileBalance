<!--
 *
 * Проект:    MobileBalance
 * Описание:  Заметки для разработчиков по алгоритму взаимодействия расширения MobileBalance
 *            с JavaScript-скриптами для опроса страниц личных кабинетов провайдеров
 * Редакция:  2025.08.07
 *
-->

Примечания: 1. Скрипты можно дополнительно изучить на примере плагинов, входящих в состав расширения.
               Наборы файлов скриптов после установки расширения находятся в каталоге "providers" его
               файловой структуры.
               После установки расширения его файловая структура с каталогом "providers" располагается
               (для браузеров, в которых тестирование проводилось) по следующему пути:

               Chrome: "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Extensions\
                         <ID_расширения>\<#_версии_расширения>\providers\"
               Yandex: "%LOCALAPPDATA%\Yandex\YandexBrowser\User Data\Default\Extensions\
                         <ID_расширения>\<#_версии_расширения>\providers\"
               Edge:   "%LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Extensions\
                         <ID_расширения>\<#_версии_расширения>\providers\"
               где
               %LOCALAPPDATA%      - системная переменная пути к данным профиля пользователя.
                                     Чаще всего это маршрут: "C:\Users\<Имя_пользователя>\AppData\Local"
               ID_расширения       - символьная строка идентификатора расширения. Например,
                                     "oogdlalfhmhjbdbgefpgmdhmfnjnlggo". Указано в сведениях браузера о
                                     расширении, откуда его и следует взять
               #_версии_расширения - номер версии расширения. Формируется механизмом подписания пакета
                                     для установки при его формировании. Например, "0.0.1_0"
               Значения в угловых скобках <> должны быть замещены соответствующими наименованиями

            2. Весьма желательно обеспечить для плагина одинаковое написание имён JSON-файлов, его
               переменной технического имени "name" и первой части имен файлов скриптов (см. дополнительно
               информацию о структуре JSON-файла описания плагина).
            3. При написании и отладке собственных скриптов для плагинов будет востребована проверка их
               пошагового взаимодействия с расширением. Для упрощения задачи отладки скриптов в коде
               модуля опроса внесены команды точек останова ("debugger") в ключевых местах взаимодействия
               расширения со скриптом. Они будут срабатывать на странице проведения опроса при открытой
               (по клавише "F12") панели инструментов отладки.
               Остановы предусмотрены перед внедрением скрипта на страницу провайдера и перед передачей
               скрипту сообщения с параметрами. Это даёт возможность успеть открыть панель разработчика
               на странице провайдера, убедиться, что скрипт в неё был внедрён (скрипт следует искать в
               панели разработчика в подразделе "Context scripts"), открыть его текст и установить в
               необходимых местах точки останова для отладки скрипта на странице провайдера.


Алгоритм взаимодействия скриптов плагинов с расширением MobileBalance
=====================================================================
Скрипты плагинов провайдеров для расширения разрабатываются на JavaScript. Скрипты очень близки по
алгоритму работы к плагинам прототипа - автономной программы MobileBalance, но при этом имеют несколько
иную структуру и большую свободу в использовании современных языковых конструкций.

В зависимости от подхода к разработке, плагин расширения представляет собой один или более JS-файлов
скриптов с расширением ".js".

Алгоритм работы скрипта предполагает его внедрение в страницу личного кабинета провайдера. При загрузке
очередной страницы личного кабинета внедрённый скрипт плагина утрачивается и в страницу требуется внедрить
очередной JS-файл скрипта. Он может быть, как тем же самым, так и отдельным файлом из набора скриптов
плагина. Соответствие имени файла скрипта текущему этапу запроса указывается в настройках плагина провайдера
(см. описание переменных для JSON-файла настроек провайдера).

Количество этапов запроса получается равным количеству страниц, обновляемых кабинетом - от стартовой (для
ввода учётных данных) до страницы личного кабинета (с которой считываются необходимые данные). Расширение
контролирует обновление страницы личного кабинета и внедряет в неё очередной (или тот же самый) скрипт из
набора для провайдера.

Стартовая страница личного кабинета провайдера определяется значением переменной "startUrl", описываемой в
JSON-файле настроек плагина провайдера.

Расширение передаёт и получает данные от скрипта, внедрённого на страницу кабинета, при помощи сообщений.
После успешного внедрения скрипта на стартовую страницу кабинета провайдера расширение направляет скрипту
сообщение со структурой формата, описанного ниже.

После передачи сообщения расширение ожидает обновления страницы кабинета провайдера, как результата работы
скрипта. Если в настройках плагина установлены параметры "respondTimeout" и "respondTimeoutValue"
(рекомендуется), то при отсутствии обновления страницы кабинета в пределах указанного времени расширение
прекратит цикл запроса по учётным данным текущей записи, инициирует выход из личного кабинета и перейдёт
к работе со следующей записью учётных данных из списка. Выход из кабинета инициируется расширением как
переход по URL из переменной "finishUrl", указанной в файле описания настроек плагина.
Отсутствие реакции опрашиваемой страницы рассматривается как проблема ввода переданных данных (сбой в
работе скрипта, неправильные значения логина / пароля, нерешённая капча, неработоспособность сайта провайдера
и прочее).
Текущая реализация расширения предполагает обработку одной страницы личного кабинета провайдера. Переход
между страницами (и, соответственно, их перезагрузка) вызовет утрату внедрённого скрипта. В результате
на такой странице не окажется механизмов обработки данных и ответа в адрес расширения. При отключённом или
не установленном значении параметра respondTimeout, вы получите эффект "зависания" опроса - расширение будет
ожидать ответ со страницы провайдера, а на странице не будет скрипта для его формирования.

В случае медленного обновления страниц личного кабинета провайдера возможно установить паузу для ожидания
завершения этого процесса. Иначе внедрение скрипта произойдёт на ещё не обновившуюся страницу кабинета и
после её обновления он будет утрачен. За паузу отвечают параметры "onUpdateDelay" и "onUpdateDelayValue"
в настройках плагина.


Расширение передаёт плагину данные сообщением в формате вида:

await chrome.tabs.sendMessage( tabId, <структура данных> )

где tabId              - идентификатор рабочей вкладки провайдера, которой адресовано сообщение
    <структура данных> - данные, передаваемые плагину (структура описана далее)

Формат структуры, передаваемой расширением скрипту (плагину) в сообщении:
-------------------------------------------------------------------------
  { message: "MB_takeData",
    action:  scriptAction,
    login:   loginValue,
    passw:   passwValue,    // Присутствует только в сообщениях для этапов, в которых требуется пароль ("pass", "log&pass")
    accIdx:  currentNumber, // Индекс позиции учётных данных в списке опроса
    detail:  detailObject   // Присутствует в сообщениях только если дополнительные параметры были ранее сохранены
  }

где 
scriptAction -  наименование текущего этапа запроса. Этапы запроса определяются для каждого провайдера
                переменными "scriptActions" в JSON-структуре их настроек.
                Пример: "scriptActions": [ "log", "pass", "polling" ]
                Для провайдеров из коллекции расширения эти настройки - в файле .\providers\providers.json
                Для провайдеров, создаваемых пользователем, настройки для провайдера формируется в локальном
                файле и загружается на странице общих настроек расширения (в подразделе провайдеров).
                Может иметь одно из следующих значений:
  - "log"       - этап ввода логина (номера) учётной записи,
  - "pass"      - этап ввода пароля,
  - "log&pass"  - этап ввода логина и пароля учётной записи (в случае, если авторизация выполняется на одной
                  странице),
  - "polling"   - этап приёма данных в личном кабинете
loginValue   -  значение логина (номера) опрашиваемой учётной записи. Задаётся в записи учётных данных
                переменной "loginValue" *
passwValue   -  значение пароля для входа под опрашиваемой учётной записью. Присутствует в структуре сообщений
                только для этапов, в которых пароль требуется ("pass", "log&pass"). Задаётся в записи учётных
                данных переменной "passwValue" *
currentNumber - индекс позиции учётных данных в списке опроса
detailObject -  объект специфичных для провайдера значений, сохраняемых применительно к учётным данным. Объект
                отсутствует в структуре сообщения, если нет необходимости в дополнительных данных или они ранее
                ещё не были сохранены.
                Для некоторых провайдеров есть необходимость сохранения токенов или подобных уникальных данных
                для применения при последующем входе в личный кабинет. Актуально для провайдеров, использующих
                авторизацию с подтверждением кода, передаваемого в SMS или письме электронной почты.
                Подробнее - ниже в описании структуры ответа скрипта в сообщении.

* В подавляющем большинстве случаев указание параметров логина и пароля учётной записи проводится в
  соответствующей форме в настройках расширения. Поэтому понимание структуры хранения записи учётных
  данных не обязательно.

Скрипт плагина обеспечивает прослушивание сообщений, направленных странице, в которой он находится. При приходе
сообщения с описанной выше структурой скрипт принимает переданные в сообщении параметры и выполняет необходимые
действия с их использованием.


Прослушивание сообщения в скрипте, оформленном в файлах по количеству этапов
============================================================================
Имя JSON-файла параметров:           MY_PROV.json
Последовательность этапов запроса:   "scriptActions": [ "login", "password", "polling" ]
Файлы скриптов:                      "scriptFiles": [ "MY_PROV1.js", "MY_PROV2.js", "MY_PROV3.js" ]


Скрипт "MY_PROV1.js" (этап ввода логина):
-----------------------------------------
chrome.runtime.onMessage.addListener( ( request, sender, sendResponse ) => {
  try {
    if ( request.message === "MB_takeData" ) {
      if ( sendResponse ) sendResponse( 'done' );  // Ответ в окно опроса для поддержания канала связи
      if ( /* проверка наличия полей ввода для логина */ ) {
// Выполнение действий по вводу логина (номера) с использованием значения "request.login"
// После этого страница перезагрузится и этот экземпляр скрипта будет утрачен
      }
      else
        if ( /* проверка наличия полей ввода для пароля */ ) {
// Если на этапе ввода логина обнаружена форма ввода пароля, то направить
// расширению сообщение с командой пропустить следующий этап (ввод пароля)
          chrome.runtime.sendMessage( sender.id, { message: "MB_workTab_skipNextPhase",
                                                   accIdx: request.accIdx }, null );
// Выполнение действий по вводу пароля. После этого страница перезагрузится
// и этот экземпляр скрипта будет утрачен
        }
    }
    else return;
  }
  catch (err) {
    console.log( err );
    return;
  }
})

Скрипт "MY_PROV2.js" (этап ввода пароля):
-----------------------------------------
chrome.runtime.onMessage.addListener( ( request, sender, sendResponse ) => {
  try {
    if ( request.message === "MB_takeData" ) {
      if ( sendResponse ) sendResponse( 'done' );  // Ответ в окно опроса для поддержания канала связи
// Выполнение действий по вводу пароля с использованием значения "request.passw"
// После этого страница перезагрузится и этот экземпляр скрипта будет утрачен
    }
    else return;
  }
  catch (err) {
    console.log( err );
    return;
  }
})

Скрипт "MY_PROV3.js" (этап считывания данных):
----------------------------------------------
let MBextentionId = undefined;
let MBResult = undefined;

chrome.runtime.onMessage.addListener( async function( request, sender, sendResponse ) {
  try {
    if ( request.message === "MB_takeData" ) {
      if ( sendResponse ) sendResponse( 'done' );  // Ответ в окно опроса для поддержания канала связи
// Сохраняем идентификатор расширения, чтобы после опроса направить ему сообщение с результатами
      MBextentionId = sender.id;
// Выполнение действий по получению необходимых данных. Это последний этап работы скрипта.
// После приёма ответа с результатами запроса от скрипта расширение инициирует переход по URL,
// указанному в переменной "finishUrl" JSON-файла настроек плагина провайдера.
    }
    else return;
  }
  catch (err) {
    console.log( err );
    return;
  }
// ... здесь код плагина для сбора нужных параметров и записи их в переменные структуры ответа ...
//
// При необходимости перейти в ходе работы плагина на другую страницу или обновить текущую,
// экземпляр скрипта, который это инициировал, будут утрачен. Для того, чтобы была возможность
// выполнять подобные действия и продолжить работу плагина, кроме сообщения расширению по пропуску
// следующего шага (см. выше) у плагина есть возможность запросить повтор текущего шага.

let errorText = 'Нужно перезагрузить страницу и повторить текущий шаг работы плагина';
chrome.runtime.sendMessage( MBextentionId, { message: 'MB_workTab_repeatCurrentPhase',
                                             error: errorText, accIdx: request.accIdx }, null );
window.location.reload(); // Перезагружаем страницу, текущий экземпляр скрипта и все переменные будут утрачены

// ... здесь код плагина для сбора нужных параметров и записи их в переменные структуры ответа ...

// Передаём результаты опроса расширению MobileBalance
chrome.runtime.sendMessage( MBextentionId, { message: 'MB_workTab_takeData', status: true,
                                             error: errorText, data: MBResult, null );

// ... здесь код плагина для корректного завершения сеанса работы в кабинете и выхода из него ...
})


Прослушивание сообщения в скрипте, оформленном в одном файле:
=============================================================
Имя JSON-файла параметров:           MY_PROV.json
Последовательность этапов запроса:   "scriptActions": [ "login", "password", "polling" ]
Файлы скриптов:                      "scriptFiles": [ "MY_PROV.js", "MY_PROV.js", "MY_PROV.js" ]

let MBextentionId = undefined;
let MBResult = undefined;
let errorText = 'Текст ошибки, который будет передан расширению в составе сообщения';

chrome.runtime.onMessage.addListener( ( request, sender, sendResponse ) => {
  try {
   if ( request.message === "MB_takeData" ) {
    if ( sendResponse ) sendResponse( 'done' );  // Ответ в окно опроса для поддержания канала связи
     switch ( request.action ) {
       case "login": {
         if ( /* проверка наличия полей ввода для логина */ ) {
// Выполнение действий по вводу пароля с использованием значения "request.passw"
// После этого страница перезагрузится и этот экземпляр скрипта будет утрачен
         }
         else
           if (/* проверка наличия полей ввода для пароля */ ) {
// Если на этапе ввода логина обнаружена форма ввода пароля, то направить
// расширению сообщение с командой пропустить следующий этап (ввод пароля)
              chrome.runtime.sendMessage( sender.id, { message: "MB_workTab_skipNextPhase",
                                                       accIdx: request.accIdx }, null );
// Выполнение действий по вводу пароля. После этого страница перезагрузится
// и этот экземпляр скрипта будет утрачен
           }
         break;
       }
       case "password": {
         if (/* проверка наличия полей ввода для пароля */ ) {
// Выполнение действий по вводу пароля с использованием значения "request.passw"
// После этого страница перезагрузится и этот экземпляр скрипта будет утрачен
         break;
       }
       case "polling": {
// Сохраняем идентификатор расширения, чтобы после опроса направить ему сообщение с результатами
         MBextentionId = sender.id;
// Выполнение действий по получению необходимых данных. Это последний этап
// работы скрипта. После получения ответа расширение инициирует выход из кабинета
         break;
       }
     }
   }
   else return;
  }
  catch( err ) {
    console.log( err );
    return;
  }
})

// Передаём результаты опроса расширению MobileBalance
chrome.runtime.sendMessage( MBextentionId, { message: 'MB_workTab_takeData', status: true,
                                             error: errorText, data: MBResult, null );

// ... здесь код плагина для корректного завершения сеанса работы в кабинете и выхода из него ...



Выполнение скриптом действий на страницах аутентификации ("log", "pass", "log&pass") обычно
приводит к обновлению страницы личного кабинета, которая даёт доступ к считыванию необходимых данных.
На этапе "polling" скрипт после сбора данных должен направить их расширению в сообщении вида:
                                                    -----------------------------------------

chrome.runtime.sendMessage( MBextentionId,
                            { message: "MB_workTab_takeData",
                              status:  requestStatus,
                              error:   requestError,
                              data:    MBResult,
                              detail:  detailObject
                            },
                            null );

где
MBextentionId - значение идентификатора расширения, ранее сохранённое на этапе приёма сообщения
                от расширения

Формат структуры, передаваемой скриптом в сообщении расширению:
---------------------------------------------------------------
{ message: "MB_workTab_takeData",
  status:  requestStatus,
  error:   requestError,
  data:    MBResult,
  detail:  detailObject   // Только если есть необходимость в сохранении дополнительных параметров
}

где
requestStatus - статус результата запроса (Boolean). Может принимать одно из двух значений:
                - true - данные успешно получены,
                - false - ошибка в ходе получения данных (полученный результат не будет
                  сохранён в истории запросов)
requestError  - текст сообщения об ошибке. Отображается в консоли разработчика для анализа ошибки
                При requestStatus = true - пустая строка ( "" )
MBResult      - структура результатов запроса (см. ниже)
detailObject  - объект специфичных данных для провайдера, сохраняемых применительно к учётным данным.
                Отсутствует, если нет необходимости в сохранении дополнительных данных.

После приёма ответа с результатами запроса от скрипта расширение инициирует переход по URL, указанному
в переменной "finishUrl" JSON-файла настроек плагина провайдера.

Расширение ожидает получить результат запроса в структуре, представленной ниже. Допускается формировать
значения не для всех полей структуры. Такие поля при разборе ответа скрипта будут заполнены расширением
значениями по умолчанию.

Структура ответа скрипта, используемая расширением (= записи истории запросов в хранилище indexedDB расширения)
--------------------------------------------------
{ QueryDateTime: 0,  // Date,    Дата и время запроса, первичный ключ (primary key)
                                 Формируется на стороне расширения
  PhoneNumber: "",   // String,  Номер учётной записи (логин), (индексируемое поле)
  Balance: 0.0,      // Double,  Текущий баланс 
  UserName: "",      // String,  ФИО пользователя
  SMS: 0,            // Integer, Кол-во оставшихся / потраченных СМС
  Minutes: 0,        // Integer, Кол-во оставшихся минут (изменено, в ответе 'Min')
  Internet: 0.0,     // Double,  Кол-во оставшегося / потраченного трафика (в Мб)
  TarifPlan: "",     // String,  Название тарифного плана
  BlockStatus: "",   // String,  Статус блокировки
  TurnOffStr: "",    // String,  Ожидаемая дата отключения
  LicSchet: "",      // String,  Лицевой счет
  BalDelta: 0.0,     // Double,  Разница от уменьшаемого - баланса предыдущего запроса
                                 Формируется на стороне расширения
  NoChangeDays: 0,   // Integer, Количество дней без изменения баланса
                                 Формируется на стороне расширения
  KreditLimit: 0.0,  // Double,  Кредитный лимит
  UslugiOn: "",      // String,  Информация о подключённых услугах
  Balance2: 0.0,     // Double,  Баланс 2
  Balance3: 0.0,     // Double,  Баланс 3
  AnyString: "",     // String,  Любая строка
  Warning: 0         // Integer, Есть изменения по сравнению с предыдущим запросом (добавлено в v1.0.11,
                     //          нужно только в записях хранилища indexedDB, в ответе плагинов не используется)
                     //          Представляет собой набор флагов-уведомлений:                 0 ( 0000 0000 ) - нет изменений;
                     //           1 ( 0000 0001 ) - Баланс без изменений дольше, чем указано; 2 ( 0000 0010 ) - Изменился статус блокировки;
                     //           4 ( 0000 0100 ) - Изменился состав или стоимость услуг;     8 ( 0000 1000 ) - Изменился тариф
                     //          Используется при отображении статуса предыдущего запроса в списке popup-меню
}

Технологическое поле статуса запроса Warning содержит набор флагов-признаков изменений по сравнению с предыдущим запросом.
Добавлено в v1.0.11 расширения. Нужно только в записях хранилища indexedDB, в ответах плагинов не анализируется. Используется
при отображении статуса предыдущего запроса в списке позиций popup-меню и при отображении данных в истории запросов.

Дополнительную информацию по соответствию структур ответа и хранения данных расширения и автономной
программы MobileBalance см. в файле "vars.mjs" (подключаемый модуль JavaScript), размещённого в корневом
каталоге расширения.

При необходимости передачи в ответе данных, специфичных для провайдера, их структура должна иметь следующий вид:
                                                                           -------------------------------------
{
  renew: boolean,    // Обязательный параметр - команда расширению по действиям по сохранению в учётных данных:
                        true  - сохранить / обновить данные;
                        false - не изменять данные.
  data1: type,       // Данные, которые необходимо сохранить, формат - в соответствии с данными для сохранения
  ...                // Предполагается что плагин, сохраняющий эти данные, готов принять их из сообщения, разобрать
  dataN: type        //   и использовать для взаимодействия с личным кабинетом провайдера
}

Расширение анализирует структуру "detail", полученную в сообщении ответа плагина. Если она пустая (undefined), то
расширение действий с ранее сохранёнными данными не выполняет.
При наличии в "detail" структуры данных, расширение выполняет действия в зависимости от значения её обязательного
параметра "renew":
renew = false, расширение действий с ранее сохранёнными данными не выполняет (аналогично отсутствию в ответе
               структуры "detail"). Если в структуре переданы данные, то они игнорируются.
renew = true,  расширение сохраняет переданные данные в параметр "detail" записи учётных данных. Сам параметр
               "renew" удаляется (не сохраняется).
               Если "detail" в записи учётных данных не было, то он будет создан с переданными данными.
               Если "detail" в записи учётных данных был, то его значения будут замещены новыми из ответа.
               Если данные для записи отсутствуют (пустая структура), то ранее сохранённые в "detail"
               данные (если они были) заместятся пустым значением (будут удалены).


Расширение, как было показано в примерах выше, может обрабатывать ещё два вида сообщения от скриптов плагинов:
                                                                      ------------------
Запрос плагином пропуска следующего шага (этапа) по сценарию работы плагина:
----------------------------------------------------------------------------
chrome.runtime.sendMessage( MBextentionId,
                            { message: "MB_workTab_skipNextPhase",
                              accIdx:  currentNumber },
                            null );

Например, если плановые шаги работы плагина описаны как "log", "pass" и "polling" и на шаге "log" плагин направит расширению
сообщение с message: "MB_workTab_skipNextPhase", то расширение не будет инициировать следующий шаг сценария "pass", а запустит
сразу шаг "polling".

Запрос плагином повторного запуска текущего шага (этапа) по сценарию работы плагина:
------------------------------------------------------------------------------------
chrome.runtime.sendMessage( MBextentionId,
                            { message: "MB_workTab_repeatCurrentPhase",
                              error:   requestError ,
                              accIdx:  currentNumber },
                            null );

где
MBextentionId - значение идентификатора расширения, ранее сохранённое на этапе приёма сообщения
                от расширения
requestError  - текст сообщения об ошибке. Отображается в консоли средств отладки для анализа ошибки
                В данном случае это не столько ошибка, сколько пояснение причины запроса повтора шага.
                Если в этом нет необходимости, то значение может быть просто пустой строкой ( "" )
currentNumber - индекс позиции учётных данных в списке опроса, полученный плагином в структуре исходного
                сообщения с "message: 'MB_takeData'"

Например, если плановые шаги работы плагина описаны как "log", "pass" и "polling" и на шаге "polling" плагин направит расширению
сообщение с message: "MB_workTab_repeatCurrentPhase", то расширение повторно инициирует шаг "polling" плагина.

Отображение сообщения в логе расширения
---------------------------------------
При необходимости плагин может направить расширению сообщение, текст которого будет отображён в консоли средств отладки браузера,
а так же в логе расширения, который может быть сохранён на диск.

chrome.tabs.sendMessage( workTab, { message: 'MB_showInLog',
                                    text: messageText } )

где
MBextentionId - значение идентификатора расширения, ранее сохранённое на этапе приёма сообщения
                от расширения
messageText - текстовая строка, которую требуется отобразить в логе окна результатов опроса расширения


Вызов плагином вспомогательного модуля
--------------------------------------
Плагин, встраиваемый в страницы опрашиваемых провайдеров, имеет ряд ограничений по возможным для использования API (например,
недоступен динамический импорт библиотек). Для того, чтобы их использовать, плагин может обратиться к основному функционалу
расширения (для которого этот функционал доступен) и получить результат с помощью механизма сообщений.

Рекомендуется формировать имя файла вспомогательного модуля в формате <имя плагина-родителя + '_helper'>. Имя родительского
плагина - как записано в ключе 'name' (см. описание структуры JSON-файла описания плагина).
Вспомогательный модуль должен быть единственным для плагина-родителя, технически являться модулем и иметь расширение '.mjs'.
Вспомогательный модуль должен быть размещён в папке расширения '/providers' вместе с файлом плагина-родителя.

Если родительский плагин использует вспомогательный модуль, то он должен быть объявлен в структуре описании провайдера в ключе
'helperFile'. Например, (см. описание структуры JSON-файла описания плагина)
 { ...,
   "helperFile": "T2_API1_helper.mjs",
   ... }

Во вспомогательном модуле должна быть единственная экспортируемая по умолчанию функция с именем в формате
<имя плагина-родителя + '_helper'>. Например, при 'name' = 'Т2_API', наименование экспортируемой функции =
'Т2_API_helper': export { Т2_API_helper as default }

function <имя плагина-родителя + '_helper'> ( provider, args ) { ... }

Входные значение функции, экспортируемой вспомогательным модулем:
  'provider' - объект данных провайдера, для которого требуется выполнить действия. Объект предварительно подготавливается в
               расширении при инициализации опроса.
  'args'     - объект с параметрами, переданными плагином-родителем для использования при выполнении действий вспомогательным
               модулем

Формат объекта, передаваемого в 'args' может быть любым. Вспомогательный модуль должен быть готов их принять и использовать. 

Вспомогательный модуль загружается скриптом окна опроса учётных данных при первом обращении за его использованием со стороны
родительского плагина. Ссылка на функцию, импортированную из вспомогательного модуля помещается в объект данных провайдера в
элемент с ключём 'helperFunc'.

Ключ 'helperFunc' предварительно подготавливается при инициации окна опроса. На этом этапе так же проверяется доступность файла
всмомогательного модуля с именем 'helperFile' в папке '/providers'. При ошибках ключ 'helperFunc' в структуре объекта провайдера
не создаётся, при успешном обнаружении - ключ 'helperFunc' создаётся со значением 'null'.

Вспомогательный модуль вызывается скриптом окна опроса учётных данных по запросу от родительского плагина сообщением вида:

chrome.runtime.sendMessage( MBextentionId,
                            { message: 'MB_helperClaim', args: <данные> } );
где
MBextentionId - значение идентификатора расширения, ранее сохранённое на этапе приёма сообщения
                от расширения
структура данных, передаваемых расширению:
  message     - "MB_helperClaim"
  args        - объект с параметрами, передаваемыми плагином-родителем для выполнения действий
                вспомогательным модулем (или импортируемыми им модулями-библиотеками)

Расширение передаёт экспортированной функции вспомогательного модуля объект параметров как параметр 'args'.

При успешном завершении вспомогательный модуль должен возвращать объект формата:
  { data: <данные>, respond: <boolean> }
  где data    - данные для передачи плагину-родителю, являющиеся результатом работы вспомогательного
                модуля. Формат данных - любой необходимый для дальнейшей работы плагина-родителя
      respond - (Boolean) true = направить ответ плагину-родителю, false - ответ не отправлять

При ошибках в работе вспомогательного модуля, он должен возвращать значение 'undefined'

После завершения работы вспомогательного модуля расширение передаёт результат его работы родительскому плагину (в зависимости
от значения параметра 'helper.respond' в структуре ответа вспомогательного модуля) в сообщении вида:

await chrome.tabs.sendMessage( tabId, <структура данных> )

где 
    tabId              - идентификатор рабочей вкладки провайдера, которой адресовано сообщение
    <структура данных> - данные, передаваемые плагину (структура описана далее)

Структура данных для передачи родительскому плагину:
  { message: "MB_takeData",
    action:  "helperResult",  // Передаётся результат работы вспомогательного модуля
    helper:  <результат>      // Данные, являющиеся результатом работы вспомогательного модуля, для передачи плагину-родителю
  }

Структура данных результата работы вспомогательного модуля для передачи плагину-родителю:
<результат>: { data: <объект с результатами работы вспомогательного модуля>, respond: true }

где
  <объект с результатами работы вспомогательного модуля> - любые необходимые данные для дальнейшей работы плагина-родителя
  respond                                                - (Boolean)   true = направлять сообщение родительскому плагину,
                                                                       false = сообщение направлять не требуется

Например,
await chrome.tabs.sendMessage( provider[ idx ].pullingTab, 
                               { message: 'MB_takeData', action: 'helperResult', helper: <ответ от вспомогательного модуля> } )
где
<ответ от вспомогательного модуля>: { data: result, respond: true } - направить плагину родителю результат работы вспомогательного модуля:

При <ответ от вспомогательного модуля>: { data: undefined, respond: false } - результат работы вспомогательного модуля не направлять


Вспомогательный модуль может, в свою очередь, загружать другие модули-библиотеки. Модули библиотек должны быть помещены в
папку расширения '/providers/modules'. Рекомендуется создавать их с расширением '.mjs'.
Если вспомогательный модуль использует модули-библиотеки, то они должны быть объявлены в структуре описании провайдера в ключе
'modules'. Перечисление задаётся массивом. Например: "modules": [ "compute_v1.mjs", "css_v2.mjs", "css_v3.mjs" ], (см. описание
структуры JSON-файла описания плагина).

Ссылки на импортированные функции модулей-библиотек должны быть помещены в элемент объекта данных провайдера с ключём 'modules'
в элементы с именами ключей, соответствующих именам файлов модулей библиотек. Например, имя библиотеки 'compute_v1.mjs', ссылка
на импортированную функцию должна быть помещена в provider.modules:
{ compute_v1.mjs: { moduleFile: "compute_v1.mjs", moduleFunc: <ссылка_на_функцию> }, ... }
Ключи предварительно подготавливаются при инициации опроса. Если импорт библиотеки ещё не проводился, то значение по ключу имеет
значение 'null'. Иначе имеет значение ссылки на функцию, ранее импортированную из модуля.

Если массив внешних модулей-библиотек определён, то элементы массив на этапе инициации опроса в объекте провайдера он будет замещён
объектом в формате:
  { 'имя_фала_1': { moduleFile: 'имя_фала_1', moduleFunc: null, }, ...
    'имя_фала_N': { moduleFile: 'имя_фала_N', moduleFunc: null, } }

В ключах 'moduleFile' элементов объекта будут имена файлов модулей-библиотек, в moduleFunc будут исходно иметь значение 'null', а при
их импорте со стороны вспомогательного модуля - получат значение функции, экспортируемой этими модулями. Предполагается, что каждый
модуль-библиотека экспортируеет одну функцию.
